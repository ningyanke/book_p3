## 5.条件变量同步

> 互斥锁是最简单的线程同步机制，Python提供的`Condition` 对象提供了对复杂线程同步问题的支持。`Condition`被称为条件变量，除了提供与`Lock`类似的`acquire和release`方法外，还提供了`wait和notify`方法。
> - 线程首先acquire一个条件变量，然后判断一些条件。如果条件不满足则wait；
> - 如果条件满足，进行一些处理改变条件后，通过notify方法通知其他线程，
> - 其他处于wait状态的线程接到通知后会重新判断条件。
> - 不断的重复这一过程，从而解决复杂的同步问题。
>
> 可以认为Condition对象维护了一个锁(`Lock/RLock`)和一个`waiting`池。线程通过`acquire`获得`Condition`对象，当调用wait方法时，线程会释放Condition内部的锁并进入blocked状态，同时在waiting池中记录这个线程。当调用notify方法时，Condition对象会从waiting池中挑选一个线程，通知其调用acquire方法尝试取到锁。
> ​	
> Condition对象的构造函数可以接受一个Lock/RLock对象作为参数，如果没有指定，则Condition对象会在内部自行创建一个RLock。除了notify方法外，Condition对象还提供了notifyAll方法，可以通知waiting池中的所有线程尝试acquire内部锁。由于上述机制，处于waiting状态的线程只能通过notify方法唤醒，所以notifyAll的作用在于防止有线程永远处于沉默状态。
>
> 演示条件变量同步的经典问题是生产者与消费者问题：假设有一群生产者(Producer)和一群消费者（Consumer）通过一个市场来交互产品。生产者的”策略“是如果市场上剩余的产品少于1000个，
> 那么就生产100个产品放到市场上；而消费者的”策略“是如果市场上剩余产品的数量多余100个，那么就消费3个产品。用Condition解决生产者与消费者问题的代码如下:
>
> ```python
> #!/usr/bin/env python
> # -*- coding: utf-8 -*-
> # @Author: ningyanke
> # @Date:   2018-01-07 02:03:14
> # @Last Modified by:   ningyanke
> # @Last Modified time: 2018-01-07 02:26:51
>
> import threading
> import time
>
>
> class Producer(threading.Thread):
>
>     def run(self):
>         global count
>         while True:
>             if con.acquire():
>                 if count > 1000:
>                     con.wait()   #
>                 else:
>                     count += 100
>                     msg = self.name + \
>                         'produce 100, count:{}'.format(str(count))
>                     print(msg)
>                     con.notify()
>                 con.release()
>                 time.sleep(1)
>
>
> class Consumer(threading.Thread):
>
>     def run(self):
>         global count
>         while True:
>             if con.acquire():
>                 if count < 100:
>                     con.wait()
>                 else:
>                     count -= 3
>                     msg = self.name + 'consumer 3, count={}'.format(str(count))
>                     print(msg)
>                     con.notify()
>                 con.release()
>                 time.sleep(1)
>
>
> count = 500
> con = threading.Condition()
>
>
> def test():
>     for i in range(2):
>         p = Producer()
>         p.start()
>     for i in range(5):
>         c = Consumer()
>         c.start()
>
>
> if __name__ == '__main__':
>     test()
> ```
>
> | 类与方法                              | 详细说明                                     |
> | --------------------------------- | ---------------------------------------- |
> | threading.Condition               | class threading.Condition(lock=None)，用于实现条件变量对象，允许多个线程wait一个条件变量，直到被一个线程notify。如果lock参数非None，必须是从外部传入的Lock或RLock。如果lock参数是None,会新建一个RLock |
> | acquire(*args)                    | acquire上面提到的传入的或新建的lock                  |
> | release()                         | release上面提到的传入的或新建的lock                  |
> | wait(timeout=None)                | 等待notify或到timeout发生，其实就是相当于acquire()一个lock，然后等待有人将其release() |
> | wait_for(predicate, timeout=None) | 等待直到condition为True，predicate是可调用的且其结果是boolean值 |
> | notify(n=1)                       | 默认唤醒一个等待condition的线程。这个方法可以唤醒最多n个等待condition的线程 |
> | notify_all()                      | 唤醒所有等待condition的线程                       |
>
> condition机制如下图所示： 
> ![这里写图片描述](http://img.blog.csdn.net/20171019161630921?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3V4aWFuZzE5OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) 
> 即Consumer等待条件满足，而Producer则触发条件满足，这样来做线程间的同步和通信。

