## 死锁/活锁

> 所谓死锁： 是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁。
>
> 相对于死锁，活锁(Livelock):
>
> ```
> 如果事务T1封锁了数据R,事务T2又请求封锁R，于是T2等待。T3也请求封锁R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求......T2可能永远等待。
> ```
>
> 这显然是饿死(Starvation)的定义，进入活锁的进程是没有阻塞的，会继续使用CPU，但外界看到整个进程都没有前进。
>
> ## 活锁实例
>
> 举个很简单的例子，两个人相向过独木桥，他们同时向一边谦让，这样两个人都过不去，然后二者同时又移到另一边，这样两个人又过不去了。如果不受其他因素干扰，两个人一直同步在移动，但外界看来两个人都没有前进，这就是活锁。
>
> 活锁会导致CPU耗尽的，解决办法是引入随机变量、增加重试次数等。
>
> 所以活锁也是程序设计上可能存在的问题，导致进程都没办法运行下去了，还耗CPU