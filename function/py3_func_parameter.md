### 函数参数的传递



> 函数参数的传递是通过自己将对象赋值给本地变量来实现的

#####  1. 参数匹配模型

> - 位置参数: 默认情况下,参数是通过其位置进行传递,从左到右,这意味,必须精确的传递一样多的参数.
>
> - 通过关键字参数,默认参数,或者参数容器可以改变这种机制
>
>   * 传递原则:从左到右
>
>
>   * 关键字参数: 使用`name = 'value'` 的语法通过参数名进行匹配,可匹配`None`
>
>   * 默认参数: 定义函数时使用`name =  'value'` 的语法直接给关键字参数一个默认值.
>
>   * 可变参数: 定义函数时使用`*`开头的参数,可用于收集任意多基于位置的参数(生成元组)
>
>     ​	          定义函数时`**`开头的参数,可用于收集任意基于关键字的参数(生成字典)
>
>   * 可变参数解包:(一一对应的关系)
>
>     ​        调用函数时,`*`开头的数据结构(字符串,元组,列表),传入函数,可在函数参数中传递位置参数
>
>     ​	调用函数时,`**`开头的数据结构(字典),传入函数,可以在函数中传递关键字参数

##### 2. 函数参数的定义

> 1.  位置参数
>
> ```python
> #def F(arg1,arg2....) #形参和实参个数必须一致,并且一一对应
> def f(x,y):
>     print(x,y)
> f(1,2) #调用函数
> ```
>
> 2.  关键字参数,默认参数
>
> ```python
> #def f(arg1,arg2=value2,....) #关键值参数,可以加入默认值,可以匹配None
> def f(x,y=None,z=3):
>     print(x,y,z)
> f(1,2)  #调用函数
> ```
>
> 3. 可变参数-位置参数:
>
> ```python
> # *:如果不确定有多少个参数,可以使用*args来表示函数的参数个数不定,但是不管有多少,在函数的内部都存
> #放在以形参名为标识符的tuple中
> In [2]: def a(*x):
>    ...:     if len(x) == 0:
>    ...:         print('None')
>    ...:     else:
>    ...:         print(x)
>    ...:         
>
> In [3]: a(1)
> (1,)
>
> In [4]: a()
> None
>
> In [5]: a(1,2,3)
> (1, 2, 3)
> ```
>
> 4. 可变参数-关键字参数:
>
> ```python
> # 形参名前加两个 ** 表示,参数在函数内部存放在以形式名为参数为标识符的dict 中,这时调用函数的方法
> # 需要采用 arg1 = value1,arg2 = value2 这样的形式
> In [7]: def a(**x):
>    ...:     if len(x) == 0:
>    ...:         print("None")
>    ...:     else:
>    ...:         print(x)
>    ...:         
>
> In [8]: a()
> None
>
> In [10]: a(x=1,y=2)
> {'y': 2, 'x': 1}
>
> ```
>
> 在函数的解析过程中,以以上4种方法优先级依次降低

##### 3. 函数参数解包

> 函数可以将数据结构为有序序列的变量拆分输出,相当于函数收集参数的反过程.比如：
>
> ```python
> def add(x,y):return x+y
> params = (1,2)
> add(*params)
> #3
> ```
>
> 不是收集函数而是作用在另一端,一个是在函数定义中用 `*` 收集剩下的实参,而这个是在函数调用时,`*`解包数据结构.
>
> 当然字典数据结构的也能用相同的方法进行解包
>
> ```python
> params = {'name':'Jack','greeting':'well met'}
> def foo(name=None,greeting=None):
>     print('%s,%s'% (greeting,name))
> foo(**params)
> # well met,Jack
> ```
>
> 这样的类似于解包可迭代序列赋值给多个变量了.

#####  4. `*`在函数中和在序列解包中的不同点

> 但是这两者之间还是有很大的区别的.序列解包得到的永远是一个列表,而函数解包参数,作用出来的是一个元组,这是因为`*`在函数中就是用于收集多余变量的.生成一个元组.而序列解包成列表参考了[PEP-3132](../remark_note/PEP-3132.md)
>
> [unpacking-sequence](../date-types/py3_pack_unpack.md)
>
> 