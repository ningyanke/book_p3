## TCP

> TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议.
>
> TCP 位于IP层之上,应用层之下, 不同主机的应用层之间经常需要可靠的,像管道一样的连接,但是IP层不提供这样的流机制,而是提供不可靠的包交换,
>
> 应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。
>
> 数据在TCP层称为Stream，数据分组称为分段（Segment）。作为比较，数据在IP层称为Datagram，数据分组称为分片（Fragment）。 UDP 中分组称为Message.

### TCP头部

> ![tcp](../../picture/10056.png)
>
> 字段详细信息
>
> - Source Port和Destination Port:分别占用16位，表示源端口号和目的端口号；用于区别主机中的不同进程，而IP地址是用来区分不同的主机的，源端口号和目的端口号配合上IP首部中的源IP地址和目的IP地址就能唯一的确定一个TCP连接；
> - Sequence Number:用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节在数据流中的序号；主要用来解决网络报乱序的问题；
> - Acknowledgment Number:32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志（下面介绍）为1时该确认序列号的字段才有效。主要用来解决不丢包的问题；
> - Offset:给出首部中32 bit字的数目，需要这个值是因为任选字段的长度是可变的。这个字段占4bit（最多能表示15个32bit的的字，即4*15=60个字节的首部长度），因此TCP最多有60字节的首部。然而，没有任选字段，正常的长度是20字节；
> - TCP Flags:TCP首部中有6个标志比特，它们中的多个可同时被设置为1，主要是用于操控TCP的状态机的，依次为URG，ACK，PSH，RST，SYN，FIN。每个标志位的意思如下
>   - URG：此标志表示TCP包的紧急指针域有效，用来保证TCP连接不被中断，并且督促中间层设备要尽快处理这些数据；
>   - ACK：此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0；
>   - PSH：这个标志位表示Push操作。所谓Push操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队；
>   - RST：这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包；
>   - SYN：表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有SYN的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手；
>   - FIN： 表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送FIN标志位的TCP数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。
> - Window:窗口大小，也就是有名的滑动窗口，用来进行流量控制

### TCP连接状态和过程

> ![10057](../../picture/10057.png)
>
> 正常一个TCP的连接都会经历3个状态
>
> - 3次握手,建立连接
> - 数据传输
> - 4次挥手,断开连接
>
> 这在之中,TCP会经历几个状态
>
> - LISTEN:首先服务端需要打开一个socket进行监听，状态为LISTEN.侦听来自远方TCP端口的连接请求 
> - SYN_SENT:客户端通过应用程序调用connect进行active open.于是客户端tcp发送一个SYN以请求建立一个连接.之后状态置为SYN_SENT. 在发送连接请求后等待匹配的连接请求 
> - SYN_RECV:服务端应发出ACK确认客户端的SYN,同时自己向客户端发送一个SYN. 之后状态置为SYN_RECV  在收到和发送一个连接请求后等待对连接请求的确认 
> - ESTABLISHED: 代表一个打开的连接，双方可以进行或已经在数据交互了。代表一个打开的连接，数据可以传送给用户 
> - FIN_WAIT1:主动关闭(active close)端应用程序调用close，于是其TCP发出FIN请求主动关闭连接，之后进入FIN_WAIT1状态 等待远程TCP的连接中断请求，或先前的连接中断请求的确认 
> - CLOSE_WAIT:被动关闭(passive close)端TCP接到FIN后，就发出ACK以回应FIN请求(它的接收也作为文件结束符传递给上层应用程序),并进入CLOSE_WAIT.  等待从本地用户发来的连接中断请求 
> - FIN_WAIT2:主动关闭端接到ACK后，就进入了FIN-WAIT-2 .从远程TCP等待连接中断请求 
> - LAST_ACK:被动关闭端一段时间后，接收到文件结束符的应用程序将调用CLOSE关闭连接。这导致它的TCP也发送一个 FIN,等待对方的ACK.就进入了LAST-ACK . 等待原来发向远程TCP的连接中断请求的确认
> - TIME_WAIT:在主动关闭端接收到FIN后，TCP就发送ACK包，并进入TIME-WAIT状态。.等待足够的时间以确保远程TCP接收到连接中断请求的确认 
> - CLOSING: 比较少见. 等待远程TCP对连接中断的确认 
> - CLOSED: 被动关闭端在接受到ACK包后，就进入了closed的状态。连接结束.没有任何连接状态 

### python建立客户端和服务端

> 用python编写TCP服务端和客户端,抓包检测TCP的过程
>
> ```python
> #!/usr/bin/env python
> # coding=utf-8
>
>
> from socket import *
>
> """
> 创建tcp服务端
> """
>
> # 创建socket套接字
> # 绑定ip 端口
> # 开启listen
> # 堵塞等待连接
> # 接收消息
> # 发送消息
>
>
> def main():
>     sersocket = socket(AF_INET, SOCK_STREAM)  # 服务于TCP
>     ip = '' # 绑定本地任意网卡
>     port = 8899
>
>     sersocket.bind((ip, port))
>     sersocket.listen(5)
>
>     while True:
>         # 等待连接
>         clisocket, ip_port = sersocket.accept()
>         while True:
>             data = clisocket.recv(1024)
>             if not data:
>                 break
>             print('<<<', data.decode(encoding='utf-8'))
>             msg = input(">>>")
>             clisocket.send(msg.encode(encoding='utf-8'))
>         clisocket.close()
>
>     sersocket.close()
>
> if __name__ == '__main__':
>     main()
> ```
>
> ```python
> #!/usr/bin/env python
> # coding=utf-8
>
> """
> tcp client
> """
> from socket import *
>
> # create socket
> # connect server
> # send/recive msg
>
> def main():
>     clisocket = socket(AF_INET, SOCK_STREAM)
>     ip = '192.168.172.12'
>     port = 8899
>     clisocket.connect((ip, port))
>    
>     while True:
>         data = input("<<<")
>         if not data:
>             break
>         clisocket.send(data.encode(encoding='utf-8'))
>         msg = clisocket.recv(1024)
>         print(msg.decode(encoding='utf-8'))
>
> if __name__ == '__main__':
>     main()
> ```

### TCP三次握手

> 第一次握手
>
> ![1](../../picture/10058.png)
>
> 第二次握手
>
> ![1](../../picture/10059.png)
>
> 第三次握手
>
> ![1](../../picture/10060.png)
>
> 可以看到:
>
> - 客户端发送`SYN` 包,请求和服务器建立连接
> - 服务器回应了`SYN+ACK` 包,`ACK` 是在原客户端的`SYN`包的`seq` 基础上加1,确认可以建立请求,服务器自己发送了一个包含`seq` 的`SYN` ,请求和客户端建立连接
> - 客户端接收到包后,发送一个`ACK` 确认包,(`ACK` 在服务器发送的`seq`基础上加1),并添加`seq` 告诉服务器接下来自己发送的包序号.
> - 至此,客户端和服务器之间建立TCP连接,三次握手成功
>
> 握手成功之后,客户端和服务器之间进行正常的数据交换,可以对数据流进行追踪
>
> `wireshark` 点击追踪TCP流,可以看到服务器和客户端之间的数据交互
>
> ![1](../../picture/10061.png)

### 四次挥手

> 第一次
>
> ![1](../../picture/10062.png)
>
> 第二次
>
> ![1](../../picture/10063.png)
>
> 第三次
>
> ![1](../../picture/10064.png)
>
> 第四次
>
> ![1](../../picture/10065.png)
>
> - 客户端向服务器发送`FIN+ACK` 包,告诉服务器发送端已经达到数据末尾,请求断开连接
> - 服务器向客户端发送`ACK` 确认收到消息报文
> - 服务器向客户端发送`FIN+ACK` 包,请求和客户端断开连接
> - 客户端向服务器发送`ACK`确认收到消息的报文
> - 客户端不会马上关闭连接,而是会等待`2MSL` 时间,随后关闭连接.

### 状态

> 对以上的TCP过程做流程图可以看到:
>
> ![10057](../../picture/10057.png)
>
> TCP在运行过程中处于不同的状态中(4次挥手状态):
>
> - `FIN_WAIT1`: 此时该socket在`ESTABLELISHED` 状态想要主动关闭连接,向对方发送了`FIN` 报文,此时该socket 处于`FIN_WAIT1` 状态,等待对方发送确认断开的回应.
> - `CLOSE_WAIT` : 被动关闭端接到FIN后，就发出ACK以回应FIN请求，并进入等待本地用户的连接终止请求的半关闭状态。这时可以发送数据，但不再接收数据.如果上面的代码,没有显示的去关闭socket` clisocket.close()`  那么TCP包中flagas`RESET=1` ,表示异常关闭的连接
> - `FIN_WAIT2`: 主动关闭端在FIN-WAIT-1状态下收到ACK确认包，进入等待远程TCP的连接终止请求的半关闭状态。这时可以接收数据，但不再发送数据,
> - `LAST_ACK`:被动关闭端全部数据发送完成之后，向主动关闭端发送FIN，进入等待确认包的状态
> - `TIME_WAIT`: 主动关闭端接收到FIN后，就发送ACK包，等待足够时间以确保被动关闭端收到了终止请求的确认包.按照RFC 793，一个连接可以在TIME-WAIT保证最大四分钟,即2倍SML(最大分片寿命)

### 为什么需要3次握手

> 从一种角度来说:
>
> - 如果只有一次握手，Client不能确定与Server的单向连接，更加不能确定Server与Client的单向连接；
> - 如果只有两次握手，Client确定与Server的单向连接，但是Server不能确定与Client的单向连接；
> - 只有三次握手，Client与Server才能相互确认双向连接，实现双工数据传输
>
> 从另外的角度来说;
>
> - 客户端发了两次请求链接的报文，第二条被服务器捕捉到，返回数据，完成了两次握手。数据传送完成之后，链接关闭。但是这时候，第一条拥塞的请求报文现在到达了服务器端，服务器还以为客户端要又一次建立连接，于是发送确认，然后把自己敞开，等着客户端发送过来数据。于是，很多的网络资源就是这样浪费掉了

### 为什么要4次挥手

> TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。

### 为什么要等待2倍SML

> - 客户端的最后一个ACK报文在传输的时候丢失，服务器并没有接收到这个报文。这个时候服务器就会超时重传这个FIN消息，然后客户端就会重新返回最后一个ACK报文，等待两个时间周期，完成关闭。如果不等待这两个时间周期，服务器重传的那条消息就不会收到。服务器就因为接收不到客户端的信息而无法正常关闭
>
> - 允许老的重复分节在网络中消逝,即握手时产生的分片
>
>   TCP分节可能由于路由器异常而“迷途”，在迷途期间，TCP发送端可能因确认超时而重发这个分节，迷途的分节在路由器修复后也会被送到最终目的地，这个 原来的迷途分节就称为lost duplicate。在关闭一个TCP连接后，马上又重新建立起一个相同的IP地址和端口之间的TCP连接，后一个连接被称为前一个连接的化身 （incarnation)，那么有可能出现这种情况，前一个连接的迷途重复分组在前一个连接终止后出现，从而被误解成从属于新的化身。为了避免这个情 况，TCP不允许处于TIME_WAIT状态的连接启动一个新的化身，因为TIME_WAIT状态持续2MSL，就可以保证当成功建立一个TCP连接的时 候，来自连接先前化身的重复分组已经在网络中消逝



